# Milestone 3: Data Layer - Context for Next Session

## Current State

### Completed Milestones

**Milestone 1: Presentation Layer (Steps 1-9)**
- Flask application factory with configuration
- Three-tier folder structure (`presentation/`, `business/`, `data/`)
- Landing page with hero section
- Subscription form at `/subscribe`
- Thank you page at `/subscribe/confirm`
- Form preserves input on validation errors

**Milestone 2: Business Layer (Steps 10-11)**
- `SubscriptionService` class in `app/business/services/`
- Email validation with regex pattern
- Email/name normalization
- Route uses service for validation
- Error messages displayed on form

### Current Data Flow

```
User submits form
       ↓
Route gets form data (presentation)
       ↓
SubscriptionService.validate_email() (business)
       ↓
If invalid → return to form with error
       ↓
SubscriptionService.process_subscription() (business)
       ↓
print() to terminal ← THIS IS WHAT WE REPLACE
       ↓
Render thank you page
```

## Milestone 3 Overview (Steps 12-15)

### Step 12: Database Setup
- Add `flask-sqlalchemy` and `flask-migrate` to requirements
- Configure database URI in `config.py`
- Initialize SQLAlchemy in `app/__init__.py`
- Run `flask db init` to set up migrations

### Step 13: Subscriber Model
- Create `Subscriber` model in `app/data/models/`
- Fields: id, email (unique), name, subscribed_at
- Create initial migration with `flask db migrate`
- Apply with `flask db upgrade`

### Step 14: Repository Pattern
- Create `SubscriberRepository` in `app/data/repositories/`
- Methods: `find_by_email()`, `create()`, `exists()`
- Repository handles all database operations
- Keeps SQLAlchemy queries out of services

### Step 15: Connecting the Layers
- Update `SubscriptionService` to use repository
- Add duplicate email check before saving
- Update route to handle "already subscribed" error
- Full flow: Route → Service → Repository → Database

## Architecture After Milestone 3

```
┌─────────────────────────────────────────────────────────────┐
│                    PRESENTATION LAYER                        │
│  app/presentation/                                           │
│  ├── routes/public.py      → HTTP handling                  │
│  └── templates/            → User interface                 │
└─────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────┐
│                     BUSINESS LAYER                           │
│  app/business/services/                                      │
│  └── subscription_service.py                                │
│      ├── validate_email()      → Input validation           │
│      ├── normalize_email()     → Data transformation        │
│      └── subscribe()           → Orchestrates full flow     │
└─────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────┐
│                       DATA LAYER                             │
│  app/data/                                                   │
│  ├── models/subscriber.py      → SQLAlchemy model           │
│  └── repositories/             → Data access                │
│      └── subscriber_repository.py                           │
└─────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────┐
│                       DATABASE                               │
│  SQLite (development) / PostgreSQL (production)             │
└─────────────────────────────────────────────────────────────┘
```

## Key Design Decisions

### Why Repository Pattern?

1. **Separation of concerns** - Services don't know about SQLAlchemy
2. **Testability** - Can mock repository in service tests
3. **Flexibility** - Could swap database without changing services
4. **Single responsibility** - Repository only does CRUD

### Database Choice

- **Development:** SQLite (`sqlite:///news_flash.db`)
- **Production:** PostgreSQL (configured via environment variable)
- Flask-SQLAlchemy handles both transparently

### Migration Strategy

Using Flask-Migrate (Alembic wrapper):
- `flask db init` - one-time setup
- `flask db migrate -m "message"` - generate migration
- `flask db upgrade` - apply migrations
- `flask db downgrade` - rollback if needed

## Files to Create/Modify

### New Files

```
app/data/models/subscriber.py          # Subscriber SQLAlchemy model
app/data/repositories/subscriber_repository.py  # Data access layer
migrations/                            # Generated by Flask-Migrate
```

### Modified Files

```
requirements.txt                       # Add flask-sqlalchemy, flask-migrate
app/config.py                          # Add SQLALCHEMY_DATABASE_URI
app/__init__.py                        # Initialize db, register migrations
app/business/services/subscription_service.py  # Use repository
app/presentation/templates/subscribe.html      # Show "already subscribed" error
```

## Service Changes

Current `SubscriptionService.process_subscription()` returns a dict and prints.

New approach - add `subscribe()` method:

```python
def subscribe(self, email: str, name: str) -> tuple[bool, str]:
    """
    Full subscription flow: validate → check duplicate → save.

    Returns:
        (success, error_message)
    """
    # Validate
    is_valid, error = self.validate_email(email)
    if not is_valid:
        return False, error

    # Normalize
    email = self.normalize_email(email)
    name = self.normalize_name(name)

    # Check duplicate (uses repository)
    if self.repository.exists(email):
        return False, "This email is already subscribed"

    # Save (uses repository)
    self.repository.create(email=email, name=name)
    return True, ""
```

## Testing Strategy

### Verification Points

1. **Database setup:** `flask db upgrade` runs without errors
2. **Model creation:** Can create Subscriber in Flask shell
3. **Repository:** CRUD operations work
4. **Integration:** Form submission saves to database
5. **Duplicate handling:** Same email twice shows error

### Manual Test Flow

```bash
# 1. Submit new email
curl -X POST localhost:5000/subscribe/confirm \
  -d "email=test@example.com&name=Test"
# → Should show thank you page

# 2. Check database
sqlite3 instance/news_flash.db "SELECT * FROM subscribers;"
# → Should show the subscriber

# 3. Submit same email again
curl -X POST localhost:5000/subscribe/confirm \
  -d "email=test@example.com&name=Test"
# → Should show "already subscribed" error
```

## Potential Challenges

### SQLAlchemy Initialization Order

The `db` object must be created before models import it. Typical pattern:

```python
# app/__init__.py
from flask_sqlalchemy import SQLAlchemy

db = SQLAlchemy()

def create_app():
    app = Flask(__name__)
    db.init_app(app)

    # Import models AFTER db.init_app
    from app.data.models import subscriber

    return app
```

### Circular Imports

Repository imports Model, Model imports db, db is in `__init__.py`. Solution:
- Create `db` in `app/__init__.py`
- Models import `db` from `app`
- Repositories import models directly

### Application Context

Repository operations need Flask application context. In routes this is automatic. In tests or shell:

```python
with app.app_context():
    repo.create(email="test@example.com", name="Test")
```

## Exercise Planning

Exercise 7 should cover:
1. Adding dependencies and configuration
2. Creating the Subscriber model
3. Running migrations
4. Creating the repository
5. Updating the service to use repository
6. Testing the complete flow

The exercise should emphasize:
- Why each layer only talks to adjacent layers
- How the repository pattern enables testing
- Database migrations for schema changes
