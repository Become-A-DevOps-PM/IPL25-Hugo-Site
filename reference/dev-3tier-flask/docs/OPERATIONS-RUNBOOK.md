# Operations Runbook: Dev Three-Tier Flask

## Goal

Deploy the complete dev-3tier-flask application to Azure, including infrastructure provisioning, application deployment, database configuration, and admin user creation.

> **What this runbook covers:**
>
> - Provisioning Azure infrastructure using Infrastructure as Code (Bicep)
> - Deploying a Flask application to an Azure VM
> - Configuring PostgreSQL database credentials securely
> - Creating the initial admin user for application access
> - Verifying the complete deployment end-to-end

## Prerequisites

> **Before starting, ensure you have:**
>
> - Azure subscription with Contributor access
> - Azure CLI 2.50+ installed and configured
> - SSH key pair at `~/.ssh/id_rsa` and `~/.ssh/id_rsa.pub` (or `id_ed25519`)
> - `jq` JSON processor installed
> - Git installed
> - Bash shell (macOS Terminal, Linux, or WSL on Windows)

## Architecture Overview

This deployment creates a simplified three-tier architecture on Azure:

```
Internet ──HTTPS(443)──→ VM (Ubuntu 24.04) ──HTTP(5001)──→ Flask/Gunicorn
                         nginx reverse proxy
                         └──PostgreSQL(5432)──→ Azure PostgreSQL
```

> **Infrastructure Components:**
>
> | Component | Azure Resource | Specification |
> |-----------|----------------|---------------|
> | Web/App Server | Virtual Machine | Standard_B1s, Ubuntu 24.04 LTS |
> | Database | PostgreSQL Flexible Server | Standard_B1ms, PostgreSQL 16 |
> | Network | VNet + Subnet + NSG | 10.0.0.0/16 with SSH/HTTP/HTTPS rules |
> | SSL | Self-signed certificate | Generated by cloud-init |
>
> **Estimated Costs:** ~$20/month (all resources use lowest-cost tiers)
>
> **Deployment Time:** 10-15 minutes total

## Deployment Steps

### Overview

1. **Prepare Local Environment**
2. **Configure Secrets**
3. **Provision Azure Infrastructure**
4. **Deploy Application**
5. **Create Initial Admin User**
6. **Verify Deployment**

### **Step 1:** Prepare Local Environment

Before provisioning any Azure resources, verify that all required tools are installed and properly configured. This prevents failures mid-deployment.

1. **Verify Azure CLI installation:**

   ```bash
   az --version
   ```

   > Expected output: `azure-cli 2.50.0` or higher

2. **Log in to Azure:**

   ```bash
   az login
   ```

   > This opens a browser window for authentication. After successful login, you'll see a list of available subscriptions.

3. **Verify the correct subscription is active:**

   ```bash
   az account show --query "{name:name, id:id}" -o table
   ```

   > If you need to change subscriptions:
   >
   > ```bash
   > az account set --subscription "Your Subscription Name"
   > ```

4. **Verify SSH key exists:**

   ```bash
   ls -la ~/.ssh/id_rsa.pub || ls -la ~/.ssh/id_ed25519.pub
   ```

   > If no SSH key exists, generate one:
   >
   > ```bash
   > ssh-keygen -t rsa -b 4096 -C "your-email@example.com"
   > ```

5. **Verify jq is installed:**

   ```bash
   jq --version
   ```

   > If not installed:
   >
   > - macOS: `brew install jq`
   > - Ubuntu/Debian: `sudo apt install jq`

6. **Navigate to the project directory:**

   ```bash
   cd reference/dev-3tier-flask
   ```

> **Quick check:** All commands return valid output without errors

### **Step 2:** Configure Secrets

The deployment requires a secure password for the PostgreSQL database. This is stored locally in `parameters.json` which is gitignored to prevent accidental commits.

1. **Run the secrets initialization script:**

   ```bash
   ./infrastructure/scripts/init-secrets.sh
   ```

   > This script:
   >
   > - Generates a cryptographically secure password
   > - Creates `infrastructure/parameters.json` with the password
   > - Validates password strength requirements

2. **Verify the parameters file was created:**

   ```bash
   ls -la infrastructure/parameters.json
   ```

3. **Optionally view the generated configuration (without the password):**

   ```bash
   jq '.parameters | keys' infrastructure/parameters.json
   ```

   > Expected output: `["dbAdminPassword", "dbAdminUsername"]`

> **Security Warning**
>
> - **NEVER** commit `parameters.json` to version control
> - The file is already in `.gitignore`
> - If you need to share credentials, use Azure Key Vault or a secure secrets manager
>
> **Quick check:** `infrastructure/parameters.json` exists and contains database credentials

### **Step 3:** Provision Azure Infrastructure

This step creates all Azure resources using Bicep Infrastructure as Code templates. The provisioning script handles resource group creation, Bicep deployment, and output retrieval.

1. **Run the infrastructure provisioning script:**

   ```bash
   ./infrastructure/provision.sh
   ```

   > The script will:
   >
   > 1. Check prerequisites (Azure CLI, jq, SSH key)
   > 2. Validate the password in parameters.json
   > 3. Create resource group `rg-flask-dev` in `swedencentral`
   > 4. Deploy Bicep templates (VNet, VM, PostgreSQL)
   > 5. Display the VM public IP and PostgreSQL FQDN

2. **Wait for PostgreSQL to be fully ready:**

   ```bash
   ./deploy/scripts/wait-for-postgresql.sh
   ```

   > PostgreSQL Flexible Server takes 5-15 minutes to reach "Ready" state after Bicep deployment completes. This script polls the server status every 30 seconds.

3. **Wait for VM cloud-init to complete:**

   ```bash
   ./deploy/scripts/wait-for-cloud-init.sh
   ```

   > Cloud-init installs nginx, Python, fail2ban, and configures the systemd service. This takes 2-3 minutes after VM boot.

4. **Verify resources were created:**

   ```bash
   az resource list -g rg-flask-dev -o table
   ```

   > Expected resources:
   >
   > - `vm-app` (Virtual Machine)
   > - `pip-app` (Public IP Address)
   > - `nic-app` (Network Interface)
   > - `vnet-flask-dev` (Virtual Network)
   > - `nsg-default` (Network Security Group)
   > - `psql-flask-dev` (PostgreSQL Flexible Server)

> **Timing Notes:**
>
> - Total infrastructure provisioning: 8-12 minutes
> - PostgreSQL is the slowest component (5-15 minutes)
> - VM with cloud-init: 2-3 minutes
>
> **Quick check:** All resources show in the resource list, PostgreSQL state is "Ready"

### **Step 4:** Deploy Application

With infrastructure ready, deploy the Flask application code to the VM. The deployment script handles file transfer, dependency installation, database configuration, and service startup.

1. **Run the application deployment script:**

   ```bash
   ./deploy/deploy.sh
   ```

   > The script performs these operations:
   >
   > 1. Extracts database credentials from `parameters.json`
   > 2. Copies application files to `/opt/flask-app/` via SCP
   > 3. Sets correct file permissions
   > 4. Installs Python dependencies from `requirements.txt`
   > 5. Configures `DATABASE_URL` in `/etc/flask-app/app.env`
   > 6. Initializes database tables using SQLAlchemy
   > 7. Enables and starts the `flask-app` systemd service

2. **Wait for the Flask application to respond:**

   ```bash
   ./deploy/scripts/wait-for-flask-app.sh
   ```

   > This script polls the `/api/health` endpoint until it returns `{"status": "ok"}`, confirming the full request path (nginx → Gunicorn → Flask) is working.

3. **Get the VM public IP address:**

   ```bash
   source config.sh
   VM_IP=$(get_vm_public_ip)
   echo "Application URL: https://$VM_IP/"
   ```

4. **Access the application in your browser:**

   Open `https://<VM_IP>/` in your browser.

   > **Note:** You will see a security warning because the SSL certificate is self-signed. This is expected for development environments. Click "Advanced" and "Proceed" to continue.

> **Application Endpoints:**
>
> | Endpoint | Description |
> |----------|-------------|
> | `GET /` | Landing page |
> | `GET /register` | Registration form |
> | `GET /demo` | Demo form with entries |
> | `GET /api/health` | Health check endpoint |
> | `GET /admin/attendees` | Admin view (requires login) |
>
> **Quick check:** Browser shows the landing page, health endpoint returns `{"status": "ok"}`

### **Step 5:** Create Initial Admin User

The admin user is required to access protected routes like `/admin/attendees` and `/admin/export/csv`. The user is created using a Flask CLI command via SSH.

1. **SSH to the VM:**

   ```bash
   source config.sh
   VM_IP=$(get_vm_public_ip)
   ssh azureuser@$VM_IP
   ```

2. **Navigate to the application directory and activate the virtual environment:**

   ```bash
   cd /opt/flask-app
   source venv/bin/activate
   ```

3. **Load the database environment variables:**

   ```bash
   eval $(sudo cat /etc/flask-app/app.env)
   ```

4. **Create the admin user:**

   ```bash
   flask create-admin admin
   ```

   > You will be prompted to enter and confirm a password. Requirements:
   >
   > - Minimum 8 characters
   > - The password is hashed with PBKDF2 before storage

5. **Verify the user was created:**

   ```bash
   flask shell
   >>> from app.models import User
   >>> User.query.all()
   [<User admin>]
   >>> exit()
   ```

6. **Exit the SSH session:**

   ```bash
   exit
   ```

7. **Test the admin login:**

   - Navigate to `https://<VM_IP>/auth/login`
   - Enter username: `admin`
   - Enter the password you created
   - You should be redirected to `/admin/attendees`

> **Alternative: Create admin user in one command**
>
> ```bash
> source config.sh
> ssh_to_vm "cd /opt/flask-app && source venv/bin/activate && eval \$(sudo cat /etc/flask-app/app.env) && flask create-admin admin"
> ```
>
> **Quick check:** Can log in at `/auth/login` and access `/admin/attendees`

### **Step 6:** Verify Deployment

Run the comprehensive verification test suite to confirm all components are working correctly.

1. **Run the verification tests:**

   ```bash
   ./deploy/scripts/verification-tests.sh
   ```

   > This runs 6 tests:
   >
   > | Test | Endpoint | Verification |
   > |------|----------|--------------|
   > | E1 | `/api/health` | Returns `{"status": "ok"}` |
   > | E2 | `/` | Landing page loads |
   > | E3 | `/demo` | Demo page loads |
   > | E4 | `/api/entries` | Returns JSON array |
   > | E5 | Database | `SELECT 1` succeeds |
   > | E6 | Schema | `entries` table exists |

2. **Review the test results:**

   > Expected output:
   >
   > ```
   > Total: 6 | Passed: 6 | Failed: 0
   > Classification: PASS
   > ```

3. **Perform manual verification:**

   - Open `https://<VM_IP>/` - landing page displays
   - Open `https://<VM_IP>/demo` - demo form works
   - Open `https://<VM_IP>/register` - registration form displays
   - Submit the registration form - redirects to `/thank-you`
   - Open `https://<VM_IP>/auth/login` - login page displays
   - Log in as admin - redirects to `/admin/attendees`
   - Click "Export CSV" - downloads attendee list

> **Success Indicators:**
>
> - All 6 verification tests pass
> - All pages load without errors
> - Forms submit correctly
> - Admin authentication works
> - Database persists data
>
> **Quick check:** 6/6 tests pass, manual verification complete

## Common Issues

> **If you encounter problems:**
>
> **PostgreSQL takes too long to provision:**
>
> - PostgreSQL Flexible Server can take up to 20 minutes in some regions
> - The wait script has a 20-minute timeout
> - Check Azure Portal for any provisioning errors
>
> **SSH connection refused:**
>
> - Cloud-init may still be running - wait 2-3 minutes
> - Check NSG rules allow SSH (port 22)
> - Verify the correct SSH key is configured
>
> **Application returns 502 Bad Gateway:**
>
> - Flask service may not be running: `ssh_to_vm "sudo systemctl status flask-app"`
> - Check Flask logs: `ssh_to_vm "sudo journalctl -u flask-app -n 50"`
>
> **Database connection errors:**
>
> - Verify DATABASE_URL: `ssh_to_vm "sudo cat /etc/flask-app/app.env"`
> - Test database connectivity: `ssh_to_vm "eval \$(sudo cat /etc/flask-app/app.env) && psql \"\$DATABASE_URL\" -c 'SELECT 1;'"`
>
> **Health endpoint not responding:**
>
> - Check nginx: `ssh_to_vm "sudo systemctl status nginx"`
> - Check nginx error log: `ssh_to_vm "sudo tail -20 /var/log/nginx/error.log"`

## Cleanup

When you're finished with the deployment, remove all Azure resources to stop incurring costs.

1. **Run the cleanup script:**

   ```bash
   ./delete-all.sh
   ```

   > This will:
   >
   > - Prompt for confirmation before deletion
   > - Delete the entire resource group and all contained resources
   > - Show a progress indicator during deletion

2. **Verify resources are deleted:**

   ```bash
   az group show -n rg-flask-dev 2>/dev/null || echo "Resource group deleted"
   ```

   > Expected output: `Resource group deleted`

3. **Clean up local secrets (optional):**

   ```bash
   rm infrastructure/parameters.json
   ```

> **Deletion Time:** 3-8 minutes depending on resources

## Operational Commands Reference

> **SSH Access:**
>
> ```bash
> source config.sh
> VM_IP=$(get_vm_public_ip)
> ssh azureuser@$VM_IP
> ```
>
> **View Application Logs:**
>
> ```bash
> ssh_to_vm "sudo journalctl -u flask-app -f"
> ```
>
> **View nginx Access Logs:**
>
> ```bash
> ssh_to_vm "sudo tail -f /var/log/nginx/access.log"
> ```
>
> **Restart Flask Service:**
>
> ```bash
> ssh_to_vm "sudo systemctl restart flask-app"
> ```
>
> **Restart nginx:**
>
> ```bash
> ssh_to_vm "sudo systemctl restart nginx"
> ```
>
> **Check Service Status:**
>
> ```bash
> ssh_to_vm "sudo systemctl status flask-app nginx"
> ```
>
> **Test Database Connection:**
>
> ```bash
> ssh_to_vm "eval \$(sudo cat /etc/flask-app/app.env) && psql \"\$DATABASE_URL\" -c 'SELECT COUNT(*) FROM registration;'"
> ```

## Summary

You have successfully deployed the dev-3tier-flask application to Azure:

- Provisioned Azure infrastructure using Bicep IaC
- Deployed a Flask application with nginx reverse proxy
- Configured PostgreSQL database with secure credentials
- Created an admin user for protected routes
- Verified all components work end-to-end

> **Key Resources Created:**
>
> | Resource | Name | Purpose |
> |----------|------|---------|
> | Resource Group | `rg-flask-dev` | Container for all resources |
> | Virtual Machine | `vm-app` | Hosts nginx + Flask |
> | PostgreSQL | `psql-flask-dev` | Database server |
> | VNet | `vnet-flask-dev` | Network isolation |
>
> **Endpoints:**
>
> | URL | Purpose |
> |-----|---------|
> | `https://<VM_IP>/` | Application landing page |
> | `https://<VM_IP>/admin/attendees` | Admin dashboard |
> | `https://<VM_IP>/api/health` | Health check endpoint |

## Done!

The deployment is complete. You can now use this application for development, testing, or as a reference for production deployments.

For automated deployments using GitHub Actions, see the companion document: `CI-CD-PIPELINE.md`
